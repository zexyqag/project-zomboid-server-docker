<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Project Zomboid Server Docker • Env Reference</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0b1020;
      --card: #111a33;
      --text: #e8eeff;
      --muted: #9fb0dd;
      --line: #29365e;
      --accent: #7ba2ff;
    }

    @media (prefers-color-scheme: light) {
      :root {
        --bg: #f5f7ff;
        --card: #ffffff;
        --text: #0f1730;
        --muted: #4a5a8f;
        --line: #d7def5;
        --accent: #2d5bdb;
      }
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.45;
    }

    .wrap {
      width: 100%;
      margin: 0 auto;
      padding: 20px;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 16px;
    }

    h1 {
      margin: 0 0 4px;
      font-size: 1.5rem;
    }

    .meta {
      color: var(--muted);
      font-size: .95rem;
      margin-bottom: 16px;
    }

    .controls {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      margin-bottom: 14px;
    }

    @media (min-width: 760px) {
      .controls {
        grid-template-columns: 180px 260px 1fr auto;
      }
    }

    .toggle-control {
      display: flex;
      align-items: flex-end;
      margin-bottom: 16px;
      gap: 8px;
      color: var(--muted);
      font-size: .9rem;
      white-space: nowrap;
    }

    .toggle-control input {
      width: auto;
      margin: 0;
    }

    select, input {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: var(--card);
      color: var(--text);
      font-size: .95rem;
    }

    option {
      color: var(--text);
      background: var(--card);
    }

    .stats {
      color: var(--muted);
      font-size: .9rem;
      margin-bottom: 12px;
    }

    .results-layout {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    @media (min-width: 1100px) {
      .results-layout {
        grid-template-columns: 300px minmax(0, 1fr);
        align-items: start;
      }
    }

    .section {
      margin: 14px 0 0;
      border: 1px solid var(--line);
      border-radius: 10px;
      overflow: hidden;
    }

    .section h2 {
      margin: 0;
      padding: 10px 12px;
      font-size: 1rem;
      border-bottom: 1px solid var(--line);
      background: color-mix(in oklab, var(--card), var(--line) 18%);
    }

    .toc {
      margin: 0;
      padding: 10px 12px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: color-mix(in oklab, var(--card), var(--line) 10%);
    }

    @media (min-width: 1100px) {
      .toc {
        position: sticky;
        top: 16px;
        max-height: calc(100vh - 32px);
        overflow: auto;
      }
    }

    .toc-title {
      margin: 0 0 8px;
      color: var(--muted);
      font-size: .9rem;
      font-weight: 600;
    }

    .toc-list {
      margin: 0;
      padding: 0;
      display: block;
      list-style: none;
    }

    .toc-list li {
      margin: 0 0 6px;
    }

    .toc-list li:last-child {
      margin-bottom: 0;
    }

    .toc-section-title {
      display: block;
      color: var(--text);
      font-size: .92rem;
      font-weight: 600;
      margin: 0 0 4px;
    }

    .toc-sublist {
      margin: 0;
      padding: 0 0 0 14px;
      list-style: none;
      border-left: 1px solid var(--line);
    }

    .toc-sublist li {
      margin: 0 0 5px;
    }

    .section-group {
      margin-top: 16px;
      padding-left: 10px;
      border-left: 1px solid color-mix(in oklab, var(--line), transparent 20%);
    }

    .section-group.depth-0 {
      margin-top: 0;
      padding-left: 0;
      border-left: 0;
    }

    .group-title {
      margin: 0 0 8px;
      font-size: 1.05rem;
      color: var(--muted);
    }

    .toc-link {
      color: var(--accent);
      text-decoration: none;
      font-size: .9rem;
    }

    .toc-link:hover {
      text-decoration: underline;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
    }

    th, td {
      border-bottom: 1px solid var(--line);
      padding: 10px 12px;
      vertical-align: top;
      text-align: left;
      font-size: .92rem;
      word-wrap: break-word;
    }

    th {
      color: var(--muted);
      font-weight: 600;
    }

    tr:last-child td { border-bottom: 0; }

    .name {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: .9rem;
    }

    .source {
      color: var(--muted);
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: .82rem;
      white-space: pre-wrap;
    }

    .cell-link {
      color: var(--accent);
      text-decoration: none;
    }

    .cell-link:hover {
      text-decoration: underline;
    }

    .empty {
      color: var(--muted);
      padding: 18px 12px;
    }

  </style>
</head>
<body>
  <main class="wrap">
    <section class="card">
      <h1>Project Zomboid Server Docker • Env Reference</h1>

      <div class="controls">
        <label>
          <span class="meta">Channel</span>
          <select id="channelSelect" aria-label="Select channel"></select>
        </label>
        <label>
          <span class="meta">Version</span>
          <select id="versionSelect" aria-label="Select version"></select>
        </label>
        <label>
          <span class="meta">Search</span>
          <input id="searchInput" type="search" placeholder="Filter by variable name, description, section, or source…" />
        </label>
        <label class="toggle-control" for="toggleSources">
          <input id="toggleSources" type="checkbox" />
          <span>Show sources</span>
        </label>
      </div>

      <div class="stats" id="stats"></div>
      <div class="results-layout">
        <nav id="toc" class="toc" aria-label="Table of contents"></nav>
        <div id="content"></div>
      </div>
    </section>
  </main>

  <script>
    const state = {
      datasets: [],
      current: null,
      selectedChannel: null,
      search: '',
      showSources: false
    };

    function escapeHtml(value) {
      return String(value ?? '')
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#039;');
    }

    function normalizeDataset(file, json, imageTagOverride) {
      const fileName = String(file || '').split('/').pop() || String(file || '');
      const stem = fileName.replace(/\.json$/i, '');

      let channel = 'other';
      let version = stem;
      if (stem.startsWith('stable-')) {
        channel = 'stable';
        version = stem.slice('stable-'.length);
      } else if (stem.startsWith('unstable-')) {
        channel = 'unstable';
        version = stem.slice('unstable-'.length);
      }

      return {
        file,
        fileName,
        channel,
        version,
        imageTag: imageTagOverride || json?.image_tag || file,
        data: json
      };
    }

    function slugify(value) {
      return String(value ?? '')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/(^-|-$)/g, '');
    }

    function toChannelLabel(channel) {
      if (channel === 'stable') return 'Stable';
      if (channel === 'unstable') return 'Unstable';
      return 'Other';
    }

    function compareVersionStringsDesc(leftVersion, rightVersion) {
      const leftParts = String(leftVersion || '')
        .split('.')
        .map((part) => Number.parseInt(part, 10));
      const rightParts = String(rightVersion || '')
        .split('.')
        .map((part) => Number.parseInt(part, 10));

      const maxLen = Math.max(leftParts.length, rightParts.length);
      for (let index = 0; index < maxLen; index += 1) {
        const leftValue = Number.isFinite(leftParts[index]) ? leftParts[index] : 0;
        const rightValue = Number.isFinite(rightParts[index]) ? rightParts[index] : 0;
        if (leftValue !== rightValue) {
          return rightValue - leftValue;
        }
      }

      return String(rightVersion || '').localeCompare(String(leftVersion || ''));
    }

    function updateBuildSelectors() {
      const channelSelect = document.getElementById('channelSelect');
      const versionSelect = document.getElementById('versionSelect');

      const channels = [];
      const seenChannels = new Set();
      for (const dataset of state.datasets) {
        if (!seenChannels.has(dataset.channel)) {
          seenChannels.add(dataset.channel);
          channels.push(dataset.channel);
        }
      }

      if (!channels.length) {
        channelSelect.innerHTML = '';
        versionSelect.innerHTML = '';
        return;
      }

      if (!state.selectedChannel || !channels.includes(state.selectedChannel)) {
        state.selectedChannel = channels.includes('stable') ? 'stable' : channels[0];
      }

      channelSelect.innerHTML = channels
        .map((channel) => `<option value="${escapeHtml(channel)}">${escapeHtml(toChannelLabel(channel))}</option>`)
        .join('');
      channelSelect.value = state.selectedChannel;

      const versions = state.datasets
        .filter((dataset) => dataset.channel === state.selectedChannel)
        .slice()
        .sort((left, right) => compareVersionStringsDesc(left.version, right.version));

      if (!state.current || state.current.channel !== state.selectedChannel) {
        state.current = versions[0] ?? null;
      }

      versionSelect.innerHTML = versions
        .map((dataset) => {
          const label = `${dataset.version} (${dataset.imageTag})`;
          return `<option value="${escapeHtml(dataset.file)}">${escapeHtml(label)}</option>`;
        })
        .join('');

      if (state.current) {
        versionSelect.value = state.current.file;
      }
    }

    function isObject(value) {
      return value !== null && typeof value === 'object' && !Array.isArray(value);
    }

    function flattenText(value) {
      if (value == null) return '';
      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
        return String(value);
      }
      if (Array.isArray(value)) {
        return value.map(flattenText).join(' ');
      }
      if (isObject(value)) {
        return Object.values(value).map(flattenText).join(' ');
      }
      return '';
    }

    function isEntryObject(value) {
      if (!isObject(value)) return false;

      const hasNameLike = typeof value.name === 'string' || typeof value.env_name === 'string';
      const hasMetadata =
        typeof value.description === 'string' ||
        Array.isArray(value.source_ids) ||
        Array.isArray(value.replaced_by) ||
        typeof value.sources === 'string' ||
        Array.isArray(value.sources);

      return hasNameLike && hasMetadata;
    }

    function collectEntrySections(node, path = [], output = []) {
      if (!isObject(node)) return output;

      const sectionRows = [];
      const nestedObjects = [];

      for (const [key, value] of Object.entries(node)) {
        if (!isObject(value)) continue;

        if (isEntryObject(value)) {
          sectionRows.push({
            ...value,
            __entry_key: key,
            name: typeof value.name === 'string' && value.name.trim() ? value.name : key
          });
          continue;
        }

        nestedObjects.push([key, value]);
      }

      if (sectionRows.length > 0) {
        output.push({ path: [...path], rows: sectionRows });
      }

      for (const [key, value] of nestedObjects) {
        collectEntrySections(value, [...path, key], output);
      }

      return output;
    }

    function getDisplayPathParts(sectionPath) {
      const cleanPath = (sectionPath || []).filter((part) => String(part ?? '').trim() !== '');
      return cleanPath[0] === 'env' ? cleanPath.slice(1) : cleanPath;
    }

    function rowMatches(row, sectionPath, query) {
      if (!query) return true;
      const q = query.toLowerCase();
      const displayPath = getDisplayPathParts(sectionPath);
      const pathLabels = [];

      if (displayPath.length > 0) {
        pathLabels.push(displayPath.join(' / '));
        for (let index = 1; index < displayPath.length; index += 1) {
          pathLabels.push(displayPath.slice(index).join(' / '));
        }
      }

      const text = `${pathLabels.join(' ')} ${flattenText(row)}`.toLowerCase();
      return text.includes(q);
    }

    function resolveSourceText(row) {
      if (Array.isArray(row.sources)) return row.sources.join('\n');
      if (typeof row.sources === 'string') return row.sources;

      if (Array.isArray(row.source_ids)) {
        const sourceMap = state.current?.data?.meta?.sources ?? {};
        return row.source_ids
          .map((id) => sourceMap[id] || id)
          .join('\n');
      }

      return '';
    }

    function buildRowAnchorMaps(sections) {
      const rowAnchors = new WeakMap();
      const nameToAnchor = new Map();
      const slugCounts = new Map();

      for (const section of sections) {
        for (const row of section.rows) {
          if (!isObject(row)) continue;

          const rawName = typeof row.name === 'string' ? row.name.trim() : '';
          if (!rawName) continue;

          const baseSlug = slugify(rawName) || 'entry';
          const count = (slugCounts.get(baseSlug) ?? 0) + 1;
          slugCounts.set(baseSlug, count);

          const anchorId = `entry-${baseSlug}-${count}`;
          rowAnchors.set(row, anchorId);

          if (!nameToAnchor.has(rawName)) {
            nameToAnchor.set(rawName, anchorId);
          }
        }
      }

      return { rowAnchors, nameToAnchor };
    }

    function renderReplacedByCell(row, nameToAnchor) {
      if (!Array.isArray(row.replaced_by)) return '';

      return row.replaced_by
        .map((entry) => {
          const label = String(entry ?? '').trim();
          if (!label) return '';

          const anchorId = nameToAnchor.get(label);
          if (!anchorId) {
            return escapeHtml(label);
          }

          return `<a class="cell-link" href="#${escapeHtml(anchorId)}">${escapeHtml(label)}</a>`;
        })
        .filter(Boolean)
        .join('<br>');
    }

    function renderRowsTable(rows, rowAnchors, nameToAnchor) {
      const objectRows = rows.filter((row) => isObject(row));
      const hasNamedShape = objectRows.some((row) => 'name' in row || 'description' in row || 'sources' in row || 'source_ids' in row);

      if (!objectRows.length) {
        const body = rows
          .map((row) => `<tr><td>${escapeHtml(flattenText(row))}</td></tr>`)
          .join('');

        return `
          <table>
            <thead><tr><th>Value</th></tr></thead>
            <tbody>${body}</tbody>
          </table>
        `;
      }

      if (hasNamedShape) {
        const showReplacedBy = objectRows.some((row) => Array.isArray(row.replaced_by) && row.replaced_by.length > 0);

        const body = objectRows
          .map((row) => {
            const name = row.name ?? '';
            const description = row.description ?? '';
            const sources = resolveSourceText(row);
            const replacedBy = renderReplacedByCell(row, nameToAnchor);
            const rowId = rowAnchors.get(row);
            return `
              <tr${rowId ? ` id="${escapeHtml(rowId)}"` : ''}>
                <td class="name">${escapeHtml(name)}</td>
                <td>${escapeHtml(description)}</td>
                ${showReplacedBy ? `<td class="source">${replacedBy}</td>` : ''}
                ${state.showSources ? `<td class="source">${escapeHtml(sources)}</td>` : ''}
              </tr>
            `;
          })
          .join('');

        const nameWidth = showReplacedBy ? (state.showSources ? '20%' : '25%') : (state.showSources ? '25%' : '35%');
        const descWidth = showReplacedBy ? (state.showSources ? '35%' : '45%') : (state.showSources ? '45%' : '65%');
        const replacedWidth = showReplacedBy ? (state.showSources ? '20%' : '30%') : '';
        const sourcesWidth = state.showSources ? (showReplacedBy ? '25%' : '30%') : '';

        return `
          <table>
            <thead>
              <tr>
                <th style="width: ${nameWidth}">Name</th>
                <th style="width: ${descWidth}">Description</th>
                ${showReplacedBy ? `<th style="width: ${replacedWidth}">Replaced by</th>` : ''}
                ${state.showSources ? `<th style="width: ${sourcesWidth}">Sources</th>` : ''}
              </tr>
            </thead>
            <tbody>${body}</tbody>
          </table>
        `;
      }

      const columnSet = new Set();
      objectRows.forEach((row) => Object.keys(row).forEach((key) => columnSet.add(key)));
      const columns = Array.from(columnSet).slice(0, 8);

      const head = columns.map((column) => `<th>${escapeHtml(column)}</th>`).join('');
      const body = objectRows
        .map((row) => {
          const cells = columns
            .map((column) => `<td>${escapeHtml(flattenText(row[column]))}</td>`)
            .join('');
          return `<tr>${cells}</tr>`;
        })
        .join('');

      return `
        <table>
          <thead><tr>${head}</tr></thead>
          <tbody>${body}</tbody>
        </table>
      `;
    }

    function render() {
      const contentEl = document.getElementById('content');
      const statsEl = document.getElementById('stats');
      const tocEl = document.getElementById('toc');

      if (!state.current) {
        contentEl.innerHTML = '<div class="empty">No dataset loaded. Ensure docs/env/index.json exists and lists valid JSON files.</div>';
        statsEl.textContent = '';
        tocEl.innerHTML = '';
        return;
      }

      const query = state.search.trim();
      const sections = collectEntrySections(state.current.data || {});
      const { rowAnchors, nameToAnchor } = buildRowAnchorMaps(sections);
      let total = 0;
      let visible = 0;

      const html = sections
        .map((section) => {
          const filteredRows = section.rows.filter((row) => rowMatches(row, section.path, query));
          total += section.rows.length;
          visible += filteredRows.length;

          if (!filteredRows.length) return '';

          const displayPath = getDisplayPathParts(section.path);
          const heading = displayPath[0] || 'root';
          const subheadingParts = displayPath.slice(1);

          return {
            heading,
            pathParts: displayPath,
            subheading: subheadingParts.join(' / '),
            rows: filteredRows
          };
        })
        .filter(Boolean);

      const sectionSlugCounts = new Map();
      const sectionsWithIds = html.map((section) => {
        const combinedHeading = section.pathParts.length
          ? section.pathParts.join(' / ')
          : section.heading;
        const baseSlug = slugify(combinedHeading) || 'section';
        const count = (sectionSlugCounts.get(baseSlug) ?? 0) + 1;
        sectionSlugCounts.set(baseSlug, count);

        return {
          ...section,
          combinedHeading,
          sectionId: `section-${baseSlug}-${count}`
        };
      });

      const rootNode = {
        name: 'root',
        key: '',
        children: new Map(),
        sections: [],
        groupId: 'group-root-1'
      };

      const groupSlugCounts = new Map();
      function createGroupId(groupKey) {
        const baseSlug = slugify(groupKey) || 'group';
        const count = (groupSlugCounts.get(baseSlug) ?? 0) + 1;
        groupSlugCounts.set(baseSlug, count);
        return `group-${baseSlug}-${count}`;
      }

      for (const section of sectionsWithIds) {
        let currentNode = rootNode;

        for (const part of section.pathParts) {
          const nextKey = currentNode.key ? `${currentNode.key} / ${part}` : part;

          if (!currentNode.children.has(part)) {
            currentNode.children.set(part, {
              name: part,
              key: nextKey,
              children: new Map(),
              sections: [],
              groupId: createGroupId(nextKey)
            });
          }

          currentNode = currentNode.children.get(part);
        }

        currentNode.sections.push(section);
      }

      function getOrderedChildren(node) {
        return Array.from(node.children.values());
      }

      function collapseLinearNodeChain(node) {
        const labels = [node.name];
        let terminalNode = node;

        while (terminalNode.sections.length === 0 && terminalNode.children.size === 1) {
          const nextNode = getOrderedChildren(terminalNode)[0];
          labels.push(nextNode.name);
          terminalNode = nextNode;
        }

        return {
          label: labels.join(' / '),
          terminalNode
        };
      }

      function renderTocList(nodes, listClassName) {
        if (!nodes.length) return '';

        const items = nodes
          .map((node) => {
            const { label, terminalNode } = collapseLinearNodeChain(node);
            const childNodes = getOrderedChildren(terminalNode);
            const isLeafWithSingleSection = childNodes.length === 0 && terminalNode.sections.length === 1;
            const targetId = isLeafWithSingleSection ? terminalNode.sections[0].sectionId : terminalNode.groupId;

            const extraSectionLinks = terminalNode.sections.length > 1
              ? `
                <ul class="toc-sublist">
                  ${terminalNode.sections
                    .map((section) => `
                      <li>
                        <a class="toc-link" href="#${escapeHtml(section.sectionId)}">${escapeHtml(section.combinedHeading)}</a>
                      </li>
                    `)
                    .join('')}
                </ul>
              `
              : '';

            const nestedList = childNodes.length ? renderTocList(childNodes, 'toc-sublist') : '';

            return `
              <li>
                <a class="toc-link toc-section-title" href="#${escapeHtml(targetId)}">${escapeHtml(label)}</a>
                ${extraSectionLinks}
                ${nestedList}
              </li>
            `;
          })
          .join('');

        return `<ul class="${escapeHtml(listClassName)}">${items}</ul>`;
      }

      const rootChildren = getOrderedChildren(rootNode);

      const tocHtml = rootChildren.length
        ? `
          <p class="toc-title">Table of contents</p>
          ${renderTocList(rootChildren, 'toc-list')}
        `
        : '';

      function renderGroupNodes(nodes, depth = 0) {
        return nodes
          .map((node) => {
            const { label, terminalNode } = collapseLinearNodeChain(node);

            const nodeTablesHtml = terminalNode.sections
              .map((section) => {
                return `
                  <section id="${escapeHtml(section.sectionId)}" class="section">
                    ${renderRowsTable(section.rows, rowAnchors, nameToAnchor)}
                  </section>
                `;
              })
              .join('');

            const childNodes = getOrderedChildren(terminalNode);
            const nestedHtml = childNodes.length ? renderGroupNodes(childNodes, depth + 1) : '';

            return `
              <section id="${escapeHtml(terminalNode.groupId)}" class="section-group depth-${depth}">
                <h2 class="group-title">${escapeHtml(label)}</h2>
                ${nodeTablesHtml}
                ${nestedHtml}
              </section>
            `;
          })
          .join('');
      }

      const groupedHtml = renderGroupNodes(rootChildren);

      statsEl.textContent = `${state.current.imageTag} • ${visible} of ${total} entries shown`;
      tocEl.innerHTML = tocHtml;
      tocEl.style.display = tocHtml ? 'block' : 'none';
      contentEl.innerHTML = groupedHtml || '<div class="empty">No entries match the current filter.</div>';
    }

    function bindEvents() {
      const channelSelect = document.getElementById('channelSelect');
      const versionSelect = document.getElementById('versionSelect');
      const searchInput = document.getElementById('searchInput');
      const toggleSources = document.getElementById('toggleSources');

      channelSelect.addEventListener('change', (event) => {
        state.selectedChannel = event.target.value;
        updateBuildSelectors();
        render();
      });

      versionSelect.addEventListener('change', (event) => {
        const selectedFile = event.target.value;
        const selected = state.datasets.find((item) => item.file === selectedFile) ?? null;
        state.current = selected;
        if (selected) {
          state.selectedChannel = selected.channel;
        }
        render();
      });

      searchInput.addEventListener('input', (event) => {
        state.search = event.target.value;
        render();
      });

      toggleSources.addEventListener('change', (event) => {
        state.showSources = event.target.checked;
        render();
      });
    }

    async function discoverFiles() {
      try {
        const response = await fetch('docs/env/index.json', { cache: 'no-store' });
        if (!response.ok) return [];

        const payload = await response.json();
        const discovered = Array.isArray(payload?.files)
          ? payload.files
              .filter((entry) => typeof entry?.file === 'string' && entry.file.endsWith('.json'))
              .map((entry) => ({
                filePath: `docs/env/${entry.file}`,
                imageTag: entry.image_tag
              }))
          : [];

        return discovered;
      } catch (error) {
        console.error('Unable to load docs/env/index.json', error);
        return [];
      }
    }

    async function loadDatasets() {
      const loaded = [];
      const files = await discoverFiles();

      for (const fileEntry of files) {
        try {
          const response = await fetch(fileEntry.filePath, { cache: 'no-store' });
          if (!response.ok) continue;
          const json = await response.json();
          loaded.push(normalizeDataset(fileEntry.filePath, json, fileEntry.imageTag));
        } catch (error) {
          console.error(`Unable to load ${fileEntry.filePath}`, error);
        }
      }

      state.datasets = loaded;
      state.current = loaded[0] ?? null;
      state.selectedChannel = state.current?.channel ?? null;
      updateBuildSelectors();
    }

    async function init() {
      bindEvents();
      await loadDatasets();
      render();
    }

    init();
  </script>
</body>
</html>