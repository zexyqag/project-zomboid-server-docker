name: Generate Env Docs

concurrency:
  group: env-docs-${{ github.repository }}
  cancel-in-progress: false

on:
  workflow_run:
    workflows:
      - Build and Publish Docker Image
    types:
      - completed
  workflow_dispatch:
    inputs:
      env_docs_tag:
        description: "Optional: generate env docs for a single image tag (e.g., stable-41.78.16)"
        required: false
        default: ""
      env_docs_tags:
        description: "Optional: generate env docs for multiple tags (comma-separated)"
        required: false
        default: ""

jobs:
  prepare:
    if: (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'main') || (github.event_name == 'workflow_dispatch' && (inputs.env_docs_tag != '' || inputs.env_docs_tags != ''))
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      has_tags: ${{ steps.set-matrix.outputs.has_tags }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Build tag matrix
        id: set-matrix
        run: |
          set -euo pipefail
          tags=()
          need_latest_versions=false

          normalize_tag() {
            local input_tag="$1"
            case "${input_tag}" in
              stable|unstable)
                need_latest_versions=true
                ;;
            esac
          }

          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            chmod +x scripts/get_latest_versions.sh
            eval "$(scripts/get_latest_versions.sh)"
            tags+=("stable-${LATEST_STABLE_VERSION}")
            tags+=("unstable-${LATEST_UNSTABLE_VERSION}")
          else
            raw_inputs=()
            if [ -n "${{ inputs.env_docs_tag }}" ]; then
              raw_inputs+=("${{ inputs.env_docs_tag }}")
            fi
            if [ -n "${{ inputs.env_docs_tags }}" ]; then
              IFS=',' read -ra raw_tags <<< "${{ inputs.env_docs_tags }}"
              for raw_tag in "${raw_tags[@]}"; do
                tag="$(echo "$raw_tag" | xargs)"
                [ -z "$tag" ] && continue
                raw_inputs+=("$tag")
              done
            fi

            for input_tag in "${raw_inputs[@]}"; do
              normalize_tag "${input_tag}"
            done

            if [ "${need_latest_versions}" = "true" ]; then
              chmod +x scripts/get_latest_versions.sh
              eval "$(scripts/get_latest_versions.sh)"
            fi

            for input_tag in "${raw_inputs[@]}"; do
              case "${input_tag}" in
                stable)
                  tags+=("stable-${LATEST_STABLE_VERSION}")
                  ;;
                unstable)
                  tags+=("unstable-${LATEST_UNSTABLE_VERSION}")
                  ;;
                *)
                  tags+=("${input_tag}")
                  ;;
              esac
            done
          fi

          if [ ${#tags[@]} -gt 0 ]; then
            mapfile -t tags < <(printf '%s\n' "${tags[@]}" | sed '/^$/d' | sort -u)
          fi

          matrix=$(printf '%s\n' "${tags[@]}" | jq -R -s '
            split("\n")
            | map(select(length>0) | {tag:., safe:(gsub("[^A-Za-z0-9_.-]"; "_"))})
            | {include:.}
          ')
          if [ "${#tags[@]}" -eq 0 ]; then
            echo "has_tags=false" >> "$GITHUB_OUTPUT"
            echo "matrix={\"include\":[]}" >> "$GITHUB_OUTPUT"
          else
            echo "has_tags=true" >> "$GITHUB_OUTPUT"
            {
              echo "matrix<<EOF"
              echo "$matrix"
              echo "EOF"
            } >> "$GITHUB_OUTPUT"
          fi

  generate:
    needs: prepare
    if: needs.prepare.outputs.has_tags == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.prepare.outputs.matrix) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set lowercase repository name
        run: |
          REPO_NAME=${{ github.repository }}
          echo "REPO_NAME_LC=${REPO_NAME,,}" >>${GITHUB_ENV}

      - name: Prepare env sources
        run: |
          TAG="${{ matrix.tag }}"
          TAG_SAFE="${{ matrix.safe }}"
          TAG_DIR="docs/env_sources/${TAG_SAFE}"
          echo "TAG=${TAG}" >> ${GITHUB_ENV}
          echo "TAG_SAFE=${TAG_SAFE}" >> ${GITHUB_ENV}
          echo "TAG_DIR=${TAG_DIR}" >> ${GITHUB_ENV}
          sudo rm -rf "${TAG_DIR}"
          mkdir -p "${TAG_DIR}"

      - name: Pull image
        run: |
          docker pull ghcr.io/${REPO_NAME_LC}:${TAG}

      - name: Extract env sources
        run: |
          docker run --rm --entrypoint /server/scripts/extract_env_sources.sh \
            -v "$PWD/${TAG_DIR}:/out" \
            ghcr.io/${REPO_NAME_LC}:${TAG} /out

      - name: Generate INI sources
        run: |
          set -euo pipefail
          sudo rm -rf "${TAG_DIR}/zomboid"
          mkdir -p "${TAG_DIR}/zomboid"
          SERVER_OUT_DIR="${TAG_DIR}/zomboid/Server"
          TARGET_INI="${SERVER_OUT_DIR}/pzserver.ini"
          docker rm -f "pz-envdocs-${TAG_SAFE}" >/dev/null 2>&1 || true
          CID=$(docker run -d --name "pz-envdocs-${TAG_SAFE}" \
            -e ADMINPASSWORD=envdocs \
            -e SERVERNAME=pzserver \
            -e SERVERPRESET=Survival \
            -v "$PWD/${TAG_DIR}/zomboid:/home/steam/Zomboid" \
            ghcr.io/${REPO_NAME_LC}:${TAG})
          found_ini=""
          for i in {1..120}; do
            if [ -f "${TARGET_INI}" ]; then
              found_ini="${TARGET_INI}"
              break
            fi
            sleep 2
          done

          if [ -z "$found_ini" ]; then
            echo "Warning: ${TARGET_INI} was not created within wait window; container logs:" >&2
            docker logs "$CID" >&2 || true
          fi

          docker stop "$CID" >/dev/null 2>&1 || true
          docker rm -f "$CID" >/dev/null 2>&1 || true
          sudo chown -R "$(id -u):$(id -g)" "${TAG_DIR}"
          if [ -z "$found_ini" ]; then
            echo "Warning: no pzserver.ini was created for $TAG" >&2
          fi

      - name: Normalize pzserver env sources
        run: |
          set -euo pipefail
          DOCS_SOURCES_DIR="${RUNNER_TEMP}/env-sources-${TAG_SAFE}"
          echo "DOCS_SOURCES_DIR=${DOCS_SOURCES_DIR}" >> ${GITHUB_ENV}
          rm -rf "${DOCS_SOURCES_DIR}"
          mkdir -p "${DOCS_SOURCES_DIR}/Server"

          if [ -d "${TAG_DIR}/zomboid/Server" ]; then
            find "${TAG_DIR}/zomboid/Server" -maxdepth 1 -type f \( -name 'pzserver*.ini' -o -name 'pzserver*.lua' \) -exec cp -f {} "${DOCS_SOURCES_DIR}/Server/" \;
          fi

          if [ -d "${TAG_DIR}/Server" ]; then
            while IFS= read -r file; do
              [ -z "${file}" ] && continue
              file_name="$(basename "${file}")"
              if [ ! -f "${DOCS_SOURCES_DIR}/Server/${file_name}" ]; then
                cp -f "${file}" "${DOCS_SOURCES_DIR}/Server/${file_name}"
              fi
            done < <(find "${TAG_DIR}/Server" -maxdepth 1 -type f \( -name 'pzserver*.ini' -o -name 'pzserver*.lua' \) | sort)
          fi

          if [ ! -f "${DOCS_SOURCES_DIR}/Server/pzserver.ini" ]; then
            echo "Error: expected ${DOCS_SOURCES_DIR}/Server/pzserver.ini for docs generation" >&2
            exit 1
          fi

      - name: Generate env docs
        run: |
          mkdir -p docs/env
          LOG_FILE="${RUNNER_TEMP}/env-docs-${TAG_SAFE}.log"
          IMAGE_TAG_VALUE="${TAG}-${GITHUB_SHA:0:7}"
          if ! SERVERNAME=pzserver ENV_SOURCES_DIR="${DOCS_SOURCES_DIR}" OUTPUT_PATH="docs/env/${TAG}.json" IMAGE_TAG="${IMAGE_TAG_VALUE}" ENV_DOCS_FAIL_ON_DUPLICATES=true bash scripts/generate_env_docs.sh >"${LOG_FILE}" 2>&1; then
            echo "generate_env_docs.sh failed; log output:" >&2
            cat "${LOG_FILE}" >&2
            exit 1
          fi

      - name: Validate replaced_by mappings
        run: |
          set -euo pipefail
          DOC_PATH="docs/env/${TAG}.json"
          jq -e '.env.custom.mods.MOD_IDS.env_name == "MOD_IDS"' "${DOC_PATH}" >/dev/null
          jq -e '.env.custom.mods.WORKSHOP_IDS.env_name == "WORKSHOP_IDS"' "${DOC_PATH}" >/dev/null
          jq -e '.env.custom.security.PASSWORD.env_name == "PASSWORD"' "${DOC_PATH}" >/dev/null
          jq -e '.env.custom.security.RCONPASSWORD.env_name == "RCONPASSWORD"' "${DOC_PATH}" >/dev/null

          jq -e '((.env.generated.ini.pzserver[""].Mods? | type) != "object") or ((.env.generated.ini.pzserver[""].Mods.replaced_by | index("MOD_IDS")) != null)' "${DOC_PATH}" >/dev/null
          jq -e '((.env.generated.ini.pzserver[""].WorkshopItems? | type) != "object") or ((.env.generated.ini.pzserver[""].WorkshopItems.replaced_by | index("WORKSHOP_IDS")) != null)' "${DOC_PATH}" >/dev/null
          jq -e '((.env.generated.ini.pzserver[""].Password? | type) != "object") or ((.env.generated.ini.pzserver[""].Password.replaced_by | index("PASSWORD")) != null)' "${DOC_PATH}" >/dev/null
          jq -e '((.env.generated.ini.pzserver[""].RCONPassword? | type) != "object") or ((.env.generated.ini.pzserver[""].RCONPassword.replaced_by | index("RCONPASSWORD")) != null)' "${DOC_PATH}" >/dev/null

      - name: Upload env docs
        uses: actions/upload-artifact@v4
        with:
          name: env-docs-${{ matrix.safe }}
          path: docs/env/${{ matrix.tag }}.json

  commit:
    needs: [prepare, generate]
    if: needs.prepare.outputs.has_tags == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Download env docs
        uses: actions/download-artifact@v4
        with:
          path: ./env-docs

      - name: Commit and push docs branch incrementally
        run: |
          set -euo pipefail

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          tmp_dir="$(mktemp -d)"
          mkdir -p "$tmp_dir/new"
          find ./env-docs -type f -name '*.json' -exec cp -f {} "$tmp_dir/new/" \;

          if git ls-remote --exit-code --heads origin docs/env >/dev/null 2>&1; then
            git fetch origin docs/env:refs/remotes/origin/docs/env
            git checkout -B docs-env-sync origin/docs/env
          else
            git checkout --orphan docs-env-sync
            git rm -rf . >/dev/null 2>&1 || true
          fi

          mkdir -p docs/env
          find "$tmp_dir/new" -maxdepth 1 -type f -name '*.json' -exec cp -f {} docs/env/ \;

          files_json="$(
            find docs/env -maxdepth 1 -type f -name '*.json' ! -name 'index.json' -print | sort \
              | while IFS= read -r file; do
                  [ -z "${file}" ] && continue
                  file_name="$(basename "${file}")"
                  image_tag="$(jq -r '.image_tag // ""' "${file}" 2>/dev/null || echo "")"
                  jq -cn --arg file "${file_name}" --arg image_tag "${image_tag}" '{file:$file,image_tag:$image_tag}'
                done \
              | jq -s 'sort_by(.file)'
          )"
          jq -n --argjson files "${files_json}" '{files:$files}' > docs/env/index.json

          git add docs/env

          if git diff --cached --quiet; then
            echo "No env docs changes to commit"
            exit 0
          fi

          git commit -m "chore: update env docs"
          git push origin HEAD:docs/env
